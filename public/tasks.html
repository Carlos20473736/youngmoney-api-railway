<!doctype html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>Young Money - Tarefas</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@400;500;600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --text-primary: #ffffff;
            --purple-neon: #8b5cf6;
            --cyan-neon: #00ddff;
            --green-neon: #10b981;
            --yellow-neon: #fbbf24;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
        }

        .container {
            max-width: 28rem;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--cyan-neon), var(--purple-neon));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .cliques-badge {
            display: inline-block;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid var(--purple-neon);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.9rem;
        }

        /* Task Card */
        .task-card {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--purple-neon);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }

        .task-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .task-icon {
            font-size: 2rem;
        }

        .task-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.25rem;
            color: var(--cyan-neon);
        }

        .task-description {
            color: #a0aec0;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }

        /* Progress Section */
        .progress-section {
            margin-bottom: 1.5rem;
        }

        .progress-item {
            margin-bottom: 1rem;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .progress-bar-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 1rem;
            height: 0.75rem;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            border-radius: 1rem;
            transition: width 0.3s ease;
            background: linear-gradient(90deg, var(--purple-neon), var(--cyan-neon));
        }

        .progress-bar.completed {
            background: linear-gradient(90deg, var(--green-neon), #34d399);
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.75rem;
            padding: 1rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--cyan-neon);
        }

        .stat-label {
            font-size: 0.85rem;
            color: #a0aec0;
            margin-top: 0.25rem;
        }

        /* Button */
        .ad-button {
            width: 100%;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 1.25rem;
            font-size: 1.1rem;
            border: 3px solid var(--purple-neon);
            background: var(--purple-neon);
            color: white;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.6);
        }

        .ad-button:hover:not(:disabled) {
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.9);
            transform: translateY(-2px);
        }

        .ad-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        .ad-button.completed {
            background: var(--green-neon);
            border-color: var(--green-neon);
        }

        /* Status Message */
        .status-message {
            text-align: center;
            padding: 1rem;
            border-radius: 0.75rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .status-message.success {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid var(--green-neon);
            color: var(--green-neon);
        }

        .status-message.warning {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid var(--yellow-neon);
            color: var(--yellow-neon);
        }

        .spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Bot√£o Voltar */
        .back-button {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid var(--purple-neon);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: scale(1.1);
        }

        .back-button i {
            color: var(--text-primary);
            font-size: 18px;
        }
    </style>
</head>
<body>

<!-- Bot√£o Voltar -->
<div class="back-button" onclick="goBack()">
    <i class="fas fa-arrow-left"></i>
</div>

<!-- ========================================
     SISTEMA DE OVERLAY FLUTUANTE DE 15 SEGUNDOS
     Sobrep√µe a tela do an√∫ncio Monetag
     Reinicia a p√°gina automaticamente ap√≥s o countdown
     ======================================== -->
<script>
    (function() {
        'use strict';

        // ========================================
        // CONFIGURA√á√ÉO DO OVERLAY FLUTUANTE
        // ========================================
        const OVERLAY_DURATION = 15; // Dura√ß√£o em segundos
        let overlayCreated = false;
        let overlayCountdown = OVERLAY_DURATION;
        let overlayInterval = null;

        console.log('[OVERLAY SYSTEM] Iniciado - Dura√ß√£o: ' + OVERLAY_DURATION + ' segundos');

        // ========================================
        // FUN√á√ÉO PARA CRIAR O OVERLAY FLUTUANTE
        // ========================================
        function createFloatingOverlay() {
            if (overlayCreated) {
                console.log('[OVERLAY] Overlay j√° existe, ignorando...');
                return;
            }

            // Overlay aparece IMEDIATAMENTE quando chamado pelo Java (clique no an√∫ncio detectado)
            // N√£o precisa verificar detectMonetagAd() porque o Java j√° detectou o clique
            overlayCreated = true;

            console.log('[OVERLAY] An√∫ncio detectado! Criando overlay flutuante de ' + OVERLAY_DURATION + ' segundos...');

            // Criar overlay TRANSPARENTE que BLOQUEIA CLIQUES e fica acima de TUDO (incluindo an√∫ncios Monetag)
            const overlay = document.createElement('div');
            overlay.id = 'monetag-block-overlay';
            overlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0, 0, 0, 0.1) !important;
                z-index: 2147483647 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                animation: fadeInOverlay 0.3s ease !important;
                pointer-events: auto !important;
            `;

            // Bloquear TODOS os eventos no overlay para impedir cliques nos an√∫ncios
            ['click', 'mousedown', 'mouseup', 'touchstart', 'touchend', 'touchmove', 'contextmenu', 'pointerdown', 'pointerup'].forEach(function(eventType) {
                overlay.addEventListener(eventType, function(e) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    console.log('[OVERLAY] Evento ' + eventType + ' bloqueado - an√∫ncio protegido');
                    return false;
                }, true);
            });

            // Mensagem do overlay com contador - MAIS TRANSPARENTE
            const message = document.createElement('div');
            message.style.cssText = `
                background: linear-gradient(135deg, rgba(26, 26, 46, 0.6) 0%, rgba(22, 33, 62, 0.6) 100%) !important;
                padding: 35px 40px !important;
                border-radius: 20px !important;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3), 0 0 20px rgba(139, 92, 246, 0.2) !important;
                text-align: center !important;
                max-width: 90% !important;
                width: 380px !important;
                animation: scaleInOverlay 0.4s ease !important;
                pointer-events: auto !important;
                border: 2px solid rgba(139, 92, 246, 0.3) !important;
                opacity: 0.85 !important;
            `;

            message.innerHTML = `
                <div style="width: 40px; height: 40px; margin: 0 auto 15px; position: relative;">
                    <svg viewBox="0 0 100 100" style="width: 100%; height: 100%; transform: rotate(-90deg);">
                        <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(139, 92, 246, 0.2)" stroke-width="8"></circle>
                        <circle id="overlay-progress-circle" cx="50" cy="50" r="45" fill="none" stroke="#00ddff" stroke-width="8" stroke-linecap="round" stroke-dasharray="283" stroke-dashoffset="0" style="transition: stroke-dashoffset 1s linear;"></circle>
                    </svg>
                    <span id="overlay-timer" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Orbitron', monospace; font-size: 14px; font-weight: 700; color: #00ddff;">${OVERLAY_DURATION}</span>
                </div>
                <p style="margin: 0; color: #a0aec0; font-size: 14px; font-family: 'Inter', sans-serif;">Realizando tarefa automaticamente...</p>
            `;

            overlay.appendChild(message);

            // Adicionar ao HTML (n√£o ao body) para ficar acima de TUDO
            document.documentElement.appendChild(overlay);

            // Adicionar anima√ß√µes CSS
            if (!document.getElementById('overlay-animations-style')) {
                const style = document.createElement('style');
                style.id = 'overlay-animations-style';
                style.textContent = `
                    @keyframes fadeInOverlay {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes scaleInOverlay {
                        from { opacity: 0; transform: scale(0.9) translateY(20px); }
                        to { opacity: 1; transform: scale(1) translateY(0); }
                    }
                    @keyframes fadeOutOverlay {
                        from { opacity: 1; }
                        to { opacity: 0; }
                    }
                    #monetag-block-overlay {
                        z-index: 2147483647 !important;
                        position: fixed !important;
                    }
                `;
                document.head.appendChild(style);
            }

            // FUN√á√ÉO PARA MANTER OVERLAY NO TOPO (acima dos iframes do Monetag)
            function keepOverlayOnTop() {
                const overlayEl = document.getElementById('monetag-block-overlay');
                if (!overlayEl) return;

                // Garantir que est√° no final do documento
                if (overlayEl.parentNode !== document.documentElement || overlayEl !== document.documentElement.lastElementChild) {
                    document.documentElement.appendChild(overlayEl);
                }

                // For√ßar z-index m√°ximo
                overlayEl.style.zIndex = '2147483647';
            }

            // Executar a cada 100ms para garantir que fica no topo
            const topInterval = setInterval(keepOverlayOnTop, 100);

            // Iniciar contador regressivo
            const circumference = 283; // 2 * PI * 45
            overlayCountdown = OVERLAY_DURATION;

            overlayInterval = setInterval(function() {
                overlayCountdown--;

                // Atualizar n√∫mero do timer
                const timerEl = document.getElementById('overlay-timer');
                const progressCircle = document.getElementById('overlay-progress-circle');

                if (timerEl) timerEl.textContent = overlayCountdown;

                // Atualizar progresso do c√≠rculo
                if (progressCircle) {
                    const progress = (OVERLAY_DURATION - overlayCountdown) / OVERLAY_DURATION;
                    progressCircle.style.strokeDashoffset = circumference * (1 - progress);
                }

                console.log('[OVERLAY] Contador: ' + overlayCountdown + ' segundos restantes');

                if (overlayCountdown <= 0) {
                    clearInterval(overlayInterval);
                    clearInterval(topInterval);

                    console.log('[OVERLAY] Contador finalizado! Reiniciando p√°gina...');

                    // REINICIAR A P√ÅGINA AUTOMATICAMENTE
                    window.location.reload();
                }
            }, 1000);

            console.log('[OVERLAY] Overlay criado com sucesso!');
        }

        // ========================================
        // FUN√á√ÉO PARA REMOVER O OVERLAY
        // ========================================
        function removeOverlay() {
            const overlay = document.getElementById('monetag-block-overlay');
            if (overlay) {
                overlay.style.animation = 'fadeOutOverlay 0.3s ease';
                setTimeout(function() {
                    overlay.remove();
                    overlayCreated = false;
                    console.log('[OVERLAY] Overlay removido!');
                }, 300);
            }
        }

        // ========================================
        // DETECTAR QUANDO O AN√öNCIO MONETAG APARECE
        // ========================================
        function detectMonetagAd() {
            // Seletores que indicam presen√ßa de an√∫ncio Monetag
            const adIndicators = [
                'iframe[src*="monetag"]',
                'iframe[src*="libtl"]',
                'iframe[src*="ad"]',
                '[class*="monetag"]',
                '[id*="monetag"]',
                'div[style*="z-index: 2147483647"]',
                'div[style*="z-index:2147483647"]',
                'iframe[style*="z-index"]',
                'div[id^="container-"]',
                'iframe[id*="google_ads"]',
                'ins.adsbygoogle'
            ];

            for (let selector of adIndicators) {
                try {
                    const elements = document.querySelectorAll(selector);
                    if (elements.length > 0) {
                        console.log('[DETECTOR] An√∫ncio detectado via seletor:', selector);
                        return true;
                    }
                } catch (e) {
                    // Ignorar erros de seletor inv√°lido
                }
            }

            // Verificar iframes que podem ser an√∫ncios
            const iframes = document.querySelectorAll('iframe');
            for (let iframe of iframes) {
                const src = iframe.src || '';
                const style = iframe.getAttribute('style') || '';

                // Verificar se √© um iframe de an√∫ncio (geralmente tem z-index alto ou src espec√≠fico)
                if (src.includes('monetag') ||
                    src.includes('libtl') ||
                    src.includes('ad') ||
                    style.includes('z-index') ||
                    iframe.style.zIndex > 1000) {
                    console.log('[DETECTOR] Iframe de an√∫ncio detectado:', src);
                    return true;
                }
            }

            return false;
        }

    // ========================================
        // OBSERVAR MUDAN√áAS NO DOM PARA DETECTAR AN√öCIOS MONETAG
        // O overlay S√ì aparece quando:
        // 1. O an√∫ncio Monetag √© detectado na tela
        // 2. E o usu√°rio J√Å TEM pelo menos 1 clique registrado
        // ========================================
        function setupAdDetectionObserver() {
            let adDetected = false;

            const observer = new MutationObserver(function(mutations) {
                if (adDetected) return;

                // Verificar se um an√∫ncio apareceu
                if (detectMonetagAd()) {
                    console.log('[OBSERVER] An√∫ncio Monetag detectado via MutationObserver!');

                    // VERIFICAR SE O USU√ÅRIO J√Å TEM CLIQUES
                    // S√≥ mostra o overlay se j√° houver pelo menos 1 clique
                    const userClicks = (typeof TaskState !== 'undefined' && TaskState.clicks) ? TaskState.clicks : 0;

                    if (userClicks >= 1) {
                        adDetected = true;
                        console.log('[OBSERVER] Usu√°rio tem ' + userClicks + ' clique(s). Mostrando overlay autom√°tico!');

                        // Criar overlay se ainda n√£o existe
                        if (!overlayCreated) {
                            createFloatingOverlay();
                        }
                    } else {
                        console.log('[OBSERVER] Usu√°rio ainda n√£o tem cliques (' + userClicks + '). Overlay N√ÉO ser√° exibido.');
                        // Resetar para poder detectar novamente no pr√≥ximo an√∫ncio
                        setTimeout(function() {
                            adDetected = false;
                        }, 2000);
                    }
                }
            });

            // Observar todo o documento
            observer.observe(document.documentElement, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['style', 'class', 'src']
            });

            console.log('[OBSERVER] Observador de an√∫ncios ativado');
            console.log('[OBSERVER] Overlay s√≥ aparecer√° quando usu√°rio tiver 1+ cliques');
        }

        // ========================================
        // INICIALIZA√á√ÉO
        // ========================================
        function initOverlaySystem() {
            console.log('[OVERLAY SYSTEM] Inicializando sistema de overlay...');
            console.log('[OVERLAY SYSTEM] Overlay s√≥ aparecer√° quando an√∫ncio Monetag for detectado na tela');

            // Configurar observador de an√∫ncios Monetag
            // O overlay S√ì aparece quando detecta o an√∫ncio, N√ÉO quando clica no bot√£o
            setupAdDetectionObserver();

            console.log('[OVERLAY SYSTEM] Sistema de overlay inicializado com sucesso!');
        }

        // Iniciar quando DOM estiver pronto
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initOverlaySystem();
        } else {
            document.addEventListener('DOMContentLoaded', initOverlaySystem);
        }

        // Expor fun√ß√£o para uso externo (opcional)
        window.MontagOverlay = {
            show: createFloatingOverlay,
            hide: removeOverlay
        };

    })();
</script>

<div class="container">
    <div class="task-card">
        <div class="task-description">
            Complete a tarefa abaixo para desbloquear a roleta e ganhar pr√™mios!
            <br><br>
            <br>‚Ä¢ Assista <strong>5 an√∫ncios</strong> (impress√µes)
            <br>‚Ä¢ Clique em <strong>1 an√∫ncio</strong>
        </div>

        <div class="progress-section">
            <div class="progress-item">
                <div class="progress-label">
                    <span><i class="fas fa-eye"></i> An√∫ncios Assistidos</span>
                    <span id="impressionCount">0/5</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="impressionBar" style="width: 0%"></div>
                </div>
            </div>

            <div class="progress-item">
                <div class="progress-label">
                    <span><i class="fas fa-hand-pointer"></i> Cliques Realizados</span>
                    <span id="clickCount">0/1</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="clickBar" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value" id="statImpressions">0</div>
                <div class="stat-label">Impress√µes</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="statClicks">0</div>
                <div class="stat-label">Cliques</div>
            </div>
        </div>

        <!-- Bot√£o ASSISTIR AN√öNCIO -->
        <button class="ad-button" id="adButton" onclick="handleAdClick()" style="display: block;">
            <i class="fas fa-circle-play"></i> ASSISTIR AN√öNCIO
        </button>

        <!-- Bot√£o GIRAR ROLETA (aparece quando tarefa √© conclu√≠da) -->
        <button class="ad-button spin-button" id="spinButton" onclick="openSpinWheel()" style="display: none; background: var(--green-neon); border-color: var(--green-neon);">
            <i class="fas fa-dice"></i> GIRAR ROLETA
        </button>

        <div id="statusMessage" style="display: none;"></div>
    </div>
</div>

<script>
    // Capturar User Agent real do dispositivo
    console.log('‚úÖ User Agent real capturado');
    console.log('UA:', navigator.userAgent);
</script>

<!-- Telegram Web App SDK - OFICIAL -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<script>
    // Criar simula√ß√£o se o SDK oficial n√£o funcionar
    window.addEventListener('DOMContentLoaded', function() {
        const now = Math.floor(Date.now() / 1000);
        const userId = 1000000000 + Math.floor(Math.random() * 1000000000);

        // Verificar se o Telegram.WebApp foi carregado corretamente
        if (!window.Telegram || !window.Telegram.WebApp || !window.Telegram.WebApp.initDataUnsafe || !window.Telegram.WebApp.initDataUnsafe.user) {
            console.log('‚ö†Ô∏è SDK oficial do Telegram n√£o forneceu dados, criando simula√ß√£o...');

            // Criar objeto Telegram se n√£o existir
            if (!window.Telegram) {
                window.Telegram = {};
            }

            // Criar ou completar WebApp
            window.Telegram.WebApp = {
                initData: `query_id=AAHdF6IQAAAAAN0XohDhrOrc&user=%7B%22id%22%3A${userId}%2C%22first_name%22%3A%22User%22%2C%22last_name%22%3A%22Test%22%2C%22username%22%3A%22testuser%22%2C%22language_code%22%3A%22pt%22%2C%22allows_write_to_pm%22%3Atrue%7D&auth_date=${now}&hash=abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890`,
                initDataUnsafe: {
                    query_id: 'AAHdF6IQAAAAAN0XohDhrOrc',
                    user: {
                        id: userId,
                        first_name: 'User',
                        last_name: 'Test',
                        username: 'testuser',
                        language_code: 'pt',
                        allows_write_to_pm: true,
                        is_premium: false
                    },
                    auth_date: now,
                    hash: 'abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890'
                },
                version: '7.0',
                platform: 'android',
                colorScheme: 'light',
                themeParams: {
                    bg_color: '#ffffff',
                    text_color: '#000000',
                    hint_color: '#999999',
                    link_color: '#2481cc',
                    button_color: '#2481cc',
                    button_text_color: '#ffffff',
                    secondary_bg_color: '#f1f1f1'
                },
                isExpanded: true,
                viewportHeight: window.innerHeight,
                viewportStableHeight: window.innerHeight,
                headerColor: '#ffffff',
                backgroundColor: '#ffffff',
                isClosingConfirmationEnabled: false,
                ready: function() {
                    console.log('‚úÖ Telegram.WebApp.ready()');
                },
                expand: function() {
                    console.log('‚úÖ Telegram.WebApp.expand()');
                },
                close: function() {
                    console.log('‚úÖ Telegram.WebApp.close()');
                },
                MainButton: {
                    text: 'CONTINUAR',
                    color: '#2481cc',
                    textColor: '#ffffff',
                    isVisible: false,
                    isActive: true,
                    setText: function(text) { this.text = text; },
                    onClick: function(callback) { },
                    show: function() { this.isVisible = true; },
                    hide: function() { this.isVisible = false; }
                },
                BackButton: {
                    isVisible: false,
                    show: function() { this.isVisible = true; },
                    hide: function() { this.isVisible = false; }
                },
                HapticFeedback: {
                    impactOccurred: function(style) { },
                    notificationOccurred: function(type) { },
                    selectionChanged: function() { }
                },
                sendData: function(data) {
                    console.log('Telegram.WebApp.sendData:', data);
                }
            };

            console.log('‚úÖ Ambiente Telegram simulado criado');
        } else {
            console.log('‚úÖ SDK oficial do Telegram funcionando');
        }

        console.log('User ID:', window.Telegram.WebApp.initDataUnsafe.user.id);
    });
</script>

<script>
    // ========================================
    // CONFIGURA√á√ÉO INTEGRADA COM NOVO SERVIDOR
    // ========================================

    const ZONE_ID = '10325249';
    const SDK_FUNC = 'show_10325249';
    const SCRIPT_SRC = 'https://libtl.com/sdk.js';

    // üéØ NOVO SERVIDOR DE POSTBACK
    const POSTBACK_SERVER = 'https://monetag-postback-server-production.up.railway.app';
    const POSTBACK_URL = `${POSTBACK_SERVER}/api/postback`;

    // üìß YOUNG MONEY API PARA BUSCAR EMAIL
    const YOUNGMONEY_API = 'https://youngmoney-api-railway-production.up.railway.app';
    const PROFILE_ENDPOINT = `${YOUNGMONEY_API}/profile`;

    // Requisitos da tarefa (ser√£o carregados da API)
    let REQUIRED_IMPRESSIONS = 5; // valor padr√£o, ser√° atualizado pela API
    let REQUIRED_CLICKS = 1; // fixo
    const AUTO_REFRESH_INTERVAL = 3000; // Atualizar a cada 3 segundos

    // Estado da aplicacao
    const TaskState = {
        userId: null,
        userEmail: null,
        impressions: 0,
        clicks: 0,
        currentClickId: null,
        isProcessing: false,
        isLoading: false,
        lastImpressions: 0,
        lastClicks: 0,
        lastEventId: 0,
        requiredImpressionsLoaded: false
    };

    // Controle do auto-refresh
    let autoRefreshInterval = null;

    // üéØ BUSCAR REQUISITOS DE IMPRESS√ïES DA API (RANDOMIZADO)
    async function fetchRequiredImpressions() {
        try {
            console.log('[REQUIREMENTS] Buscando n√∫mero de impress√µes necess√°rias da API...');

            // Usar a API monetag/progress.php que retorna os valores do banco
            const url = `${YOUNGMONEY_API}/monetag/progress.php?user_id=${TaskState.userId || 1}`;
            console.log('[REQUIREMENTS] URL:', url);

            const response = await fetch(url);
            const data = await response.json();

            console.log('[REQUIREMENTS] Resposta:', data);

            if (data.success && data.data) {
                REQUIRED_IMPRESSIONS = data.data.required_impressions || 5;
                REQUIRED_CLICKS = data.data.required_clicks || 1;
                TaskState.requiredImpressionsLoaded = true;

                console.log('[REQUIREMENTS] ‚úÖ Valores carregados da API:');
                console.log('[REQUIREMENTS]   - Impress√µes necess√°rias:', REQUIRED_IMPRESSIONS);
                console.log('[REQUIREMENTS]   - Cliques necess√°rios:', REQUIRED_CLICKS);

                // Atualizar UI com os novos valores
                updateUI();
            } else {
                console.warn('[REQUIREMENTS] ‚ö†Ô∏è Usando valores padr√£o (API n√£o retornou dados)');
            }
        } catch (error) {
            console.error('[REQUIREMENTS] ‚ùå Erro ao buscar requisitos:', error);
            console.warn('[REQUIREMENTS] ‚ö†Ô∏è Usando valores padr√£o');
        }
    }

    // üìß BUSCAR EMAIL DO PROFILE ENDPOINT (EM BACKGROUND)
    function fetchUserProfileAsync() {
        fetch(PROFILE_ENDPOINT, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
            credentials: 'include'
        })
        .then(response => response.ok ? response.json() : Promise.reject())
        .then(data => {
            let email = data.email || (data.user && data.user.email) || (data.data && data.data.email);
            TaskState.userEmail = email || 'unknown@youngmoney.com';
            console.log('[PROFILE] ‚úÖ Email obtido:', TaskState.userEmail);
        })
        .catch(err => {
            console.error('[PROFILE] ‚ùå Erro:', err);
            TaskState.userEmail = 'unknown@youngmoney.com';
        });
    }

    // üö´ INTERCEPTAR E BLOQUEAR POSTBACK DO MONETAG (TODAS AS FORMAS)

    // 1. Interceptar fetch()
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
        const url = args[0];
        if (typeof url === 'string' && url.includes('youngmoney-api-railway')) {
            // Verificar se √© postback do Monetag (com macros literais)
            if (url.includes('%7Bymid%7D') || url.includes('{ymid}')) {
                console.log('[BLOQUEIO FETCH] üö´ Postback do Monetag bloqueado:', url);

                // Detectar tipo de evento (impression ou click)
                const eventType = url.includes('event_type=click') || url.includes('event_type%3Dclick') ? 'click' : 'impression';
                console.log('[BLOQUEIO FETCH] Tipo detectado:', eventType);

                // Enviar para novo servidor
                console.log(`[BLOQUEIO FETCH] ‚úÖ ${eventType} detectado! Enviando para novo servidor...`);
                sendPostbackToNewServer(eventType);

                return Promise.resolve(new Response('', { status: 200 }));
            }
        }
        return originalFetch.apply(this, args);
    };

    // 2. Interceptar XMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url, ...rest) {
        if (typeof url === 'string' && url.includes('youngmoney-api-railway')) {
            // Verificar se √© postback do Monetag (com macros literais)
            if (url.includes('%7Bymid%7D') || url.includes('{ymid}')) {
                console.log('[BLOQUEIO XHR] üö´ Postback do Monetag bloqueado:', url);

                // Detectar tipo de evento (impression ou click)
                const eventType = url.includes('event_type=click') || url.includes('event_type%3Dclick') ? 'click' : 'impression';
                console.log('[BLOQUEIO XHR] Tipo detectado:', eventType);

                // Enviar para novo servidor
                console.log(`[BLOQUEIO XHR] ‚úÖ ${eventType} detectado! Enviando para novo servidor...`);
                sendPostbackToNewServer(eventType);

                // Redirecionar para URL vazia
                return originalXHROpen.call(this, method, 'about:blank', ...rest);
            }
        }
        return originalXHROpen.call(this, method, url, ...rest);
    };

    // 3. Interceptar Image (pixel tracking)
    const originalImage = window.Image;
    window.Image = function() {
        const img = new originalImage();
        const originalSrcSetter = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, 'src').set;
        Object.defineProperty(img, 'src', {
            set: function(value) {
                if (typeof value === 'string' && value.includes('youngmoney-api-railway')) {
                    // Verificar se √© postback do Monetag (com macros literais)
                    if (value.includes('%7Bymid%7D') || value.includes('{ymid}')) {
                        console.log('[BLOQUEIO IMG] üö´ Postback do Monetag bloqueado:', value);

                        // Detectar tipo de evento (impression ou click)
                        const eventType = value.includes('event_type=click') || value.includes('event_type%3Dclick') ? 'click' : 'impression';
                        console.log('[BLOQUEIO IMG] Tipo detectado:', eventType);

                        // Enviar para novo servidor
                        console.log(`[BLOQUEIO IMG] ‚úÖ ${eventType} detectado! Enviando para novo servidor...`);
                        sendPostbackToNewServer(eventType);

                        return; // N√£o define o src
                    }
                }
                originalSrcSetter.call(this, value);
            },
            get: function() {
                return this.getAttribute('src');
            }
        });
        return img;
    };

    // Carregar SDK do Monetag
    function loadMonetagSDK() {
        const script = document.createElement('script');
        script.src = SCRIPT_SRC;
        script.setAttribute('data-zone', ZONE_ID);
        script.setAttribute('data-sdk', SDK_FUNC);
        script.async = true;
        document.head.appendChild(script);
        console.log('[SDK] Carregando Monetag (postback interceptado)...');
    }

    // Inicializar
    function init() {
        console.log('='.repeat(50));
        console.log('[INIT] üöÄ Iniciando aplica√ß√£o (INTEGRADA)...');
        console.log('[INIT] Servidor de Postback:', POSTBACK_SERVER);

        // Verificar se interface Android existe
        console.log('[INIT] window.Android existe?', typeof window.Android !== 'undefined');
        console.log('[INIT] window.AndroidInterface existe?', typeof window.AndroidInterface !== 'undefined');

        // Tentar obter dados do Android
        if (window.Android || window.AndroidInterface) {
            try {
                const androidInterface = window.Android || window.AndroidInterface;
                console.log('[INIT] ‚úÖ Interface Android encontrada:', androidInterface);

                // Verificar se m√©todos existem
                console.log('[INIT] getUserId existe?', typeof androidInterface.getUserId === 'function');
                console.log('[INIT] getEmail existe?', typeof androidInterface.getEmail === 'function');

                // Chamar m√©todos
                const rawUserId = androidInterface.getUserId?.();
                const rawEmail = androidInterface.getEmail?.();

                console.log('[INIT] üì• Dados BRUTOS recebidos do Android:');
                console.log('[INIT]   - rawUserId:', rawUserId, '(tipo:', typeof rawUserId, ')');
                console.log('[INIT]   - rawEmail:', rawEmail, '(tipo:', typeof rawEmail, ')');

                // Processar dados
                TaskState.userId = rawUserId || 'guest_' + Date.now();
                TaskState.userEmail = rawEmail || 'guest@demo.com';

                console.log('[INIT] üì§ Dados PROCESSADOS para uso:');
                console.log('[INIT]   - TaskState.userId:', TaskState.userId);
                console.log('[INIT]   - TaskState.userEmail:', TaskState.userEmail);

            } catch (e) {
                console.error('[INIT] ‚ùå ERRO ao obter dados do Android:', e);
                TaskState.userId = 'guest_' + Date.now();
                TaskState.userEmail = 'guest@demo.com';
            }
        } else {
            TaskState.userId = 'guest_' + Date.now();
            TaskState.userEmail = 'guest@demo.com';
        }

        // üìß BUSCAR EMAIL DO PROFILE ENDPOINT (EM BACKGROUND)
        fetchUserProfileAsync();

        // üéØ BUSCAR REQUISITOS DE IMPRESS√ïES DA API (RANDOMIZADO)
        fetchRequiredImpressions();

        updateUI(); // Mostrar estado inicial (layout aparece instantaneamente)
        loadMonetagSDK();
        fetchStats(); // Buscar estatisticas do novo servidor UMA VEZ
    }

    // Buscar eventos em tempo real (API de eventos)
    async function fetchEvents() {
        try {
            const timestamp = new Date().toLocaleTimeString('pt-BR');
            console.log(`[EVENTS] [${timestamp}] Buscando novos eventos desde ID ${TaskState.lastEventId}...`);

            const url = `${POSTBACK_SERVER}/api/events?since_id=${TaskState.lastEventId}`;
            console.log('[EVENTS] URL:', url);

            const response = await fetch(url);
            const data = await response.json();

            console.log('[EVENTS] Resposta:', data);

            if (data.success && data.events && data.events.length > 0) {
                console.log(`[EVENTS] ${data.count} novo(s) evento(s) detectado(s)!`);

                data.events.forEach(event => {
                    if (event.event_type === 'impression') {
                        TaskState.impressions++;
                        console.log('[EVENTS] +1 Impressao');
                    } else if (event.event_type === 'click') {
                        TaskState.clicks++;
                        console.log('[EVENTS] +1 Clique');
                    }
                });

                TaskState.lastEventId = data.last_event_id;

                console.log('[EVENTS] OK Estatisticas atualizadas:');
                console.log('[EVENTS]   - Impressoes:', TaskState.impressions);
                console.log('[EVENTS]   - Cliques:', TaskState.clicks);

                updateUI();
            } else {
                console.log('[EVENTS] Nenhum novo evento');
            }
        } catch (error) {
            console.error('[EVENTS] Erro ao buscar eventos:', error);
        } finally {
            TaskState.isLoading = false;
            console.log('[EVENTS] Carregamento concluido');
        }
    }

    // Buscar estatisticas do novo servidor
    async function fetchStats() {
        try {
            const timestamp = new Date().toLocaleTimeString('pt-BR');
            console.log(`[STATS] [${timestamp}] Buscando estatisticas do usuario ${TaskState.userId}...`);

            // Usar a API do novo servidor (por usuario)
            const url = `${POSTBACK_SERVER}/api/stats/user/${TaskState.userId}`;
            console.log('[STATS] URL:', url);

            const response = await fetch(url);
            const data = await response.json();

            console.log('[STATS] Resposta:', data);

            if (data.ymid || data.success) {
                const newImpressions = data.total_impressions || 0;
                const newClicks = data.total_clicks || 0;

                const hasChanges = newImpressions !== TaskState.lastImpressions || newClicks !== TaskState.lastClicks;

                if (hasChanges) {
                    console.log('[STATS] MUDANCA DETECTADA!');
                    TaskState.impressions = newImpressions;
                    TaskState.clicks = newClicks;
                    TaskState.lastImpressions = newImpressions;
                    TaskState.lastClicks = newClicks;

                    console.log('[STATS] OK Estatisticas atualizadas:');
                    console.log('[STATS]   - Impressoes:', TaskState.impressions);
                    console.log('[STATS]   - Cliques:', TaskState.clicks);
                    console.log('[STATS]   - Revenue:', data.total_revenue);

                    updateUI();
                } else {
                    console.log('[STATS] Sem mudancas, nao atualizando');
                }
            }
        } catch (error) {
            console.error('[STATS] ‚ùå Erro ao buscar estat√≠sticas:', error);
        } finally {
            // Habilitar bot√£o ap√≥s carregar (sucesso ou erro)
            TaskState.isLoading = false;
            updateUI();
            console.log('[STATS] ‚úÖ Carregamento conclu√≠do, bot√£o habilitado');
        }
    }

    // Fun√ß√£o para voltar (fecha a Activity)
    function goBack() {
        console.log('[BACK] Bot√£o voltar clicado');
        if (window.Android && window.Android.closeActivity) {
            window.Android.closeActivity();
        } else if (window.history.length > 1) {
            window.history.back();
        } else {
            console.log('[BACK] Nenhuma a√ß√£o de voltar dispon√≠vel');
        }
    }

    // Atualizar interface
    function updateUI() {
        // Contadores
        document.getElementById('statImpressions').textContent = TaskState.impressions;
        document.getElementById('statClicks').textContent = TaskState.clicks;

        // Progresso de impress√µes
        const impressionProgress = Math.min((TaskState.impressions / REQUIRED_IMPRESSIONS) * 100, 100);
        document.getElementById('impressionBar').style.width = impressionProgress + '%';
        document.getElementById('impressionCount').textContent = `${TaskState.impressions}/${REQUIRED_IMPRESSIONS}`;

        if (TaskState.impressions >= REQUIRED_IMPRESSIONS) {
            document.getElementById('impressionBar').classList.add('completed');
        }

        // Progresso de cliques
        const clickProgress = Math.min((TaskState.clicks / REQUIRED_CLICKS) * 100, 100);
        document.getElementById('clickBar').style.width = clickProgress + '%';
        document.getElementById('clickCount').textContent = `${TaskState.clicks}/${REQUIRED_CLICKS}`;

        if (TaskState.clicks >= REQUIRED_CLICKS) {
            document.getElementById('clickBar').classList.add('completed');
        }

        // Bot√£o
        const button = document.getElementById('adButton');

        // üéØ IMPORTANTE: S√≥ considerar tarefa conclu√≠da se:
        // 1. Os requisitos foram carregados da API (requiredImpressionsLoaded = true)
        // 2. Impress√µes >= valor da API (ex: 26)
        // 3. Cliques >= 1
        const taskCompleted = TaskState.requiredImpressionsLoaded &&
                              TaskState.impressions >= REQUIRED_IMPRESSIONS &&
                              TaskState.clicks >= REQUIRED_CLICKS;

        console.log('[UPDATE UI] Verifica√ß√£o de conclus√£o:');
        console.log('[UPDATE UI]   - requiredImpressionsLoaded:', TaskState.requiredImpressionsLoaded);
        console.log('[UPDATE UI]   - Impress√µes:', TaskState.impressions, '/', REQUIRED_IMPRESSIONS);
        console.log('[UPDATE UI]   - Cliques:', TaskState.clicks, '/', REQUIRED_CLICKS);
        console.log('[UPDATE UI]   - Tarefa conclu√≠da:', taskCompleted);

        if (taskCompleted) {
            button.style.display = 'none';

            showStatus('<i class="fas fa-check-circle"></i> Parab√©ns! Tarefa conclu√≠da. Volte para girar a roleta!', 'success');
        } else {
            // Esconder mensagem de sucesso se tarefa n√£o est√° conclu√≠da
            hideStatus();
            button.style.display = 'block';

            // Desabilitar se estiver carregando ou processando
            button.disabled = TaskState.isLoading || TaskState.isProcessing;

            if (TaskState.isLoading) {
                button.innerHTML = '<span class="spinner"></span> CARREGANDO DADOS...';
            } else if (TaskState.isProcessing) {
                button.innerHTML = '<span class="spinner"></span> CARREGANDO...';
            } else {
                button.innerHTML = '<i class="fas fa-circle-play"></i> ASSISTIR AN√öNCIO';
            }
        }
    }

    // Enviar postback para novo servidor
    function sendPostbackToNewServer(eventType) {
        console.log('[POSTBACK] Enviando ' + eventType + ' para novo servidor');
        console.log('[POSTBACK] URL:', POSTBACK_URL);

        // üéØ SE FOR CLIQUE, MOSTRAR OVERLAY DE 15 SEGUNDOS IMEDIATAMENTE!
        if (eventType === 'click') {
            console.log('[POSTBACK] üéØ CLIQUE DETECTADO! Mostrando overlay de 15 segundos...');
            // Chamar o overlay imediatamente
            if (typeof createFloatingOverlay === 'function' && !overlayCreated) {
                createFloatingOverlay();
            } else if (window.MontagOverlay && window.MontagOverlay.show) {
                window.MontagOverlay.show();
            }
        }

        const params = new URLSearchParams({
            event_type: eventType,
            zone_id: ZONE_ID,
            ymid: TaskState.userId,
            user_email: TaskState.userEmail,
            estimated_price: eventType === 'click' ? '0.0045' : '0.0023'
        });

        const url = `${POSTBACK_URL}?${params.toString()}`;

        console.log('[POSTBACK] URL completa:', url);

        fetch(url, { method: 'GET', mode: 'cors' })
            .then(response => {
                console.log('[POSTBACK] Resposta recebida para ' + eventType);
                console.log('[POSTBACK] Status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('[POSTBACK] ' + eventType + ' enviado com sucesso');
                console.log('[POSTBACK] Resposta:', data);

                // Atualizar estat√≠sticas imediatamente
                setTimeout(() => {
                    fetchStats();
                }, 500);
            })
            .catch(err => {
                console.error('[POSTBACK] Erro ao enviar ' + eventType + ':', err);
            });
    }

    // Mostrar mensagem de status
    function showStatus(message, type) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.innerHTML = message;
        statusEl.className = `status-message ${type}`;
        statusEl.style.display = 'block';
    }

    // Esconder mensagem de status
    function hideStatus() {
        const statusEl = document.getElementById('statusMessage');
        if (statusEl) {
            statusEl.style.display = 'none';
        }
    }

    // Clique no bot√£o de an√∫ncio
    function handleAdClick() {
        if (TaskState.isProcessing) return;

        TaskState.isProcessing = true;
        updateUI();

        // Gerar click_id √∫nico
        TaskState.currentClickId = 'click_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        console.log('[AD] Click ID:', TaskState.currentClickId);

        // Verificar se SDK est√° pronto
        if (typeof window[SDK_FUNC] !== 'function') {
            console.warn('[AD] SDK n√£o est√° pronto');
            TaskState.isProcessing = false;
            updateUI();
            showStatus('‚ö†Ô∏è Aguarde o carregamento...', 'warning');
            return;
        }

        // Preparar dados para envio
        console.log('[POSTBACK] üì¶ Preparando dados para envio...');
        console.log('[POSTBACK] TaskState.userId:', TaskState.userId);
        console.log('[POSTBACK] TaskState.userEmail:', TaskState.userEmail);
        console.log('[POSTBACK] ‚úÖ Dados preparados com sucesso');

        // Mostrar an√∫ncio com ymid e requestVar (macros oficiais do Monetag)
        console.log('[AD] Chamando SDK com ymid e requestVar');
        console.log('[AD] ymid:', TaskState.userId, '| requestVar:', TaskState.userEmail);
        window[SDK_FUNC]({
            ymid: TaskState.userId,
            requestVar: TaskState.userEmail
        }).then(() => {
            console.log('[AD] ‚úÖ An√∫ncio exibido pelo Monetag');
            // Enviar postback manual de impression
            sendPostbackToNewServer('impression');

            // Aguardar um pouco e depois parar o processamento
            setTimeout(() => {
                TaskState.isProcessing = false;
                updateUI();
                fetchStats();
            }, 2000);
        }).catch(err => {
            console.error('[AD] ‚ùå Erro:', err);
            TaskState.isProcessing = false;
            updateUI();
        });
    }

    // Iniciar auto-refresh de estat√≠sticas
    function startAutoRefresh() {
        // Auto-refresh desabilitado - busca apenas uma vez ao carregar
        console.log('[AUTO-REFRESH] Desabilitado - estatisticas buscadas uma vez ao carregar');
    }

    // Parar auto-refresh de estat√≠sticas
    function stopAutoRefresh() {
        if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
            console.log('[AUTO-REFRESH] Parado');
        }

    }

    // Abrir roleta
    function openSpinWheel() {
        console.log('[SPIN] Abrindo roleta...');

        // Parar auto-refresh
        stopAutoRefresh();

        // Notificar Android
        if (window.AndroidInterface?.onTaskCompleted) {
            window.AndroidInterface.onTaskCompleted();
        } else if (window.Android?.onTaskCompleted) {
            window.Android.onTaskCompleted();
        }

        // Fechar WebView ou navegar
        if (window.Telegram?.WebApp?.close) {
            window.Telegram.WebApp.close();
        }
    }

    // Iniciar ao carregar
    window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
