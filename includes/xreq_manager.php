<?php
/**
 * X-Req Manager
 * Sistema de validação de tokens x-req gerados pelo app
 * Valida assinatura HMAC e verifica anti-replay
 */

class XReqManager {
    private $conn;
    private $user;
    
    // Chave secreta para validar assinatura (mesma usada no app C++)
    private const SECRET_KEY = "young_money_secret_2025_v1";
    
    // Tempo máximo de validade do token (90 segundos)
    private const MAX_TIME_DIFF = 90;
    
    public function __construct($conn, $user) {
        $this->conn = $conn;
        $this->user = $user;
    }
    
    /**
     * Valida um x-req token gerado pelo app
     * Formato esperado: "timestamp:signature"
     * Assinatura MD5 de: timestamp + secretKey + userAgent
     * 
     * @param string $xReq Token x-req recebido
     * @param string $userAgent User-Agent do request
     * @return bool True se válido
     * @throws Exception Se token inválido
     */
    public function validateXReq($xReq, $userAgent) {
        $userId = $this->user['id'];
        
        // 1. Verificar tamanho mínimo
        if (strlen($xReq) < 10) {
            throw new Exception("X-REQ too short");
        }
        
        // 2. Verificar formato (timestamp:signature)
        $parts = explode(':', $xReq, 2);
        if (count($parts) !== 2) {
            $this->logViolation($userId, "X-REQ invalid format", $xReq);
            throw new Exception("X-REQ invalid format (expected timestamp:signature)");
        }
        
        list($timestamp, $signature) = $parts;
        
        // 3. Validar timestamp (não pode ser muito antigo ou futuro)
        $currentTime = time() * 1000; // Converter para milissegundos
        $tokenTime = intval($timestamp);
        
        if ($tokenTime == 0) {
            $this->logViolation($userId, "X-REQ invalid timestamp", $xReq);
            throw new Exception("X-REQ invalid timestamp");
        }
        
        // Aceitar tokens com até MAX_TIME_DIFF segundos de diferença
        $timeDiff = abs($currentTime - $tokenTime) / 1000;
        if ($timeDiff > self::MAX_TIME_DIFF) {
            $this->logViolation($userId, "X-REQ expired (time diff: {$timeDiff}s)", $xReq);
            throw new Exception("X-REQ expired (timestamp too old or future)");
        }
        
        // 4. Validar assinatura MD5
        // Formato: timestamp + secretKey + userAgent
        $dataToSign = $timestamp . self::SECRET_KEY . $userAgent;
        $expectedSignature = md5($dataToSign);
        
        if (!hash_equals($expectedSignature, strtolower($signature))) {
            $this->logViolation($userId, "X-REQ invalid signature (forged token)", $xReq);
            throw new Exception("X-REQ invalid signature (not generated by legitimate app)");
        }
        
        // 5. Verificar se já foi usado (anti-replay com janela de 5 segundos)
        $stmt = $this->conn->prepare("SELECT id, created_at FROM xreq_tokens WHERE token = ? AND user_id = ? LIMIT 1");
        $stmt->bind_param("si", $xReq, $userId);
        $stmt->execute();
        $result = $stmt->get_result();
        
        if ($result->num_rows > 0) {
            $row = $result->fetch_assoc();
            $stmt->close();
            
            // Verificar se já passou 5 segundos desde o primeiro uso
            $firstUsedAt = strtotime($row['created_at']);
            $currentTime = time();
            $timeSinceFirstUse = $currentTime - $firstUsedAt;
            
            if ($timeSinceFirstUse > 5) {
                $this->logViolation($userId, "X-REQ expired (used more than 5 seconds ago)", $xReq);
                throw new Exception("X-REQ expired (can only be reused within 5 seconds)");
            }
            
            // Dentro da janela de 5 segundos - permitir reutilização
            return true;
        }
        $stmt->close();
        
        // 6. Salvar x-req como usado
        try {
            $stmt = $this->conn->prepare("INSERT INTO xreq_tokens (user_id, token, created_at, expires_at, used, used_at) VALUES (?, ?, NOW(), DATE_ADD(NOW(), INTERVAL ? SECOND), 1, NOW())");
            $maxTimeDiff = self::MAX_TIME_DIFF;
            $stmt->bind_param("isi", $userId, $xReq, $maxTimeDiff);
            $stmt->execute();
            $stmt->close();
        } catch (Exception $e) {
            throw new Exception("X-REQ validation failed: " . $e->getMessage());
        }
        
        // 7. Registrar métrica de sucesso
        $this->logMetric($userId, "xreq_validation_success");
        
        return true;
    }
    
    /**
     * Gera um novo x-req token para o app usar na próxima requisição
     * Formato: "timestamp:signature"
     * 
     * @param string $userAgent User-Agent do request
     * @return string Token x-req
     */
    public function generateXReq($userAgent) {
        $timestamp = time() * 1000; // Milissegundos
        $dataToSign = $timestamp . self::SECRET_KEY . $userAgent;
        $signature = md5($dataToSign);
        
        return $timestamp . ':' . $signature;
    }
    
    /**
     * Limpa tokens expirados (executar periodicamente)
     */
    public function cleanExpiredTokens() {
        try {
            $this->conn->query("DELETE FROM xreq_tokens WHERE expires_at < DATE_SUB(NOW(), INTERVAL 1 HOUR)");
        } catch (Exception $e) {
            error_log("[XREQ] Failed to clean expired tokens: " . $e->getMessage());
        }
    }
    
    /**
     * Registra violação de segurança
     */
    private function logViolation($userId, $reason, $token) {
        try {
            $stmt = $this->conn->prepare("INSERT INTO security_violations (user_id, violation_type, description, severity, created_at) VALUES (?, 'xreq_validation_failed', ?, 'high', NOW())");
            $stmt->bind_param("is", $userId, $reason);
            $stmt->execute();
            $stmt->close();
        } catch (Exception $e) {
            error_log("[XREQ] Failed to log violation: " . $e->getMessage());
        }
    }
    
    /**
     * Registra métrica de segurança
     */
    private function logMetric($userId, $metricType) {
        try {
            $stmt = $this->conn->prepare("INSERT INTO security_metrics (user_id, metric_type, value, created_at) VALUES (?, ?, 1, NOW())");
            $stmt->bind_param("is", $userId, $metricType);
            $stmt->execute();
            $stmt->close();
        } catch (Exception $e) {
            error_log("[XREQ] Failed to log metric: " . $e->getMessage());
        }
    }
}

/**
 * Função helper para validar x-req
 */
function validateXReqToken($conn, $user, $token, $userAgent) {
    $manager = new XReqManager($conn, $user);
    return $manager->validateXReq($token, $userAgent);
}

/**
 * Função helper para gerar novo x-req
 */
function generateNewXReq($conn, $user, $userAgent) {
    $manager = new XReqManager($conn, $user);
    return $manager->generateXReq($userAgent);
}
?>
